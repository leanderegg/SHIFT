---
title: "Establishing relationships between lwc_mean and MPa, Part 2"
author: "Indra Boving"
date: "11/9022"
output:
  html_document: default
  word_document: default
---

#Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
#install.packages("")
#devtools::install_github("an-bui/calecopal")

library(data.table)
library(janitor)
library(here)
library(tidyverse)
library(lubridate)
library(readxl)
library(gridExtra)
library(calecopal)
library(rstatix)
library(vars)
library(MuMIn)
library(lme4) #for mixed effects models
library(arm)
library(nlme)
select = dplyr::select

source(here::here("scripts", "scripts_functions", "figure_info.R"))

#datver <- "20230724"
dataversion <- paste0("Data_", datver)
```

#Data wrangling: 

```{r}
pv_new_rr_raw <- read_csv(here("data", "pv_curves", "pv_curves_long_rayna.csv"), show_col_types = FALSE) %>% 
  clean_names()%>% 
  group_by(date, tree, rehydrated, pd_or_md) %>% 
  fill(c(stem_dry_wt_g, leaves_dry_wt_g, total_nonsample_wt, leaf_area), .direction = "downup") %>% 
  ungroup() %>% 
  mutate(total_nonsample_wt = case_when(
    total_nonsample_wt %in% c(NA_real_) ~ 0, 
    TRUE ~ as.numeric(total_nonsample_wt)
  ))  %>% 
  mutate(stem_dry_wt_g = case_when(
    stem_dry_wt_g %in% c(NA_real_) ~ 0, 
    TRUE ~ as.numeric(stem_dry_wt_g)
  )) %>% 
  mutate(fresh_mass = mass_g - total_nonsample_wt, 
        dry_mass = leaves_dry_wt_g + stem_dry_wt_g, 
        water_potential = mpa) %>% 
  mutate(lwc = mass_g/dry_mass, 
         lma = dry_mass/leaf_area, 
         lwa = lwc*lma, 
         rwc = fresh_mass/swc, 
         rwd = 1 - rwc) %>% 
  unite("unique_id", c(date,tree, rehydrated, pd_or_md), sep = "_", remove = F) %>% 
  mutate(date = mdy(date)) 


pv_new_rr_df <- pv_new_rr_raw %>%
  select(unique_id, date, water_potential, lwc, lma, lwa, rwc, rwd, swc, rehydrated) %>%
  mutate(week = week(date)) %>% 
  filter(date %in% c("2023-07-27"))
```


KK:

```{r}
pv_new_kk_raw <- read_csv(here("data", "pv_curves", "pv_shift_kk.csv"), show_col_types = FALSE) %>%
  clean_names() %>%
  # mutate(fresh_mass_saturated = case_when(
  #   fresh_mass_saturated > 4 ~ fresh_mass_saturated - 2.906,
  #   TRUE ~ as.numeric(fresh_mass_saturated)),
  #   fresh_mass = case_when(
  #   fresh_mass_saturated > 4 ~ fresh_mass - 2.906,
  #   TRUE ~ as.numeric(fresh_mass)),
  # ) %>%
  mutate(lwc = fresh_mass/dry_mass,
         lma = dry_mass/leaf_area,
         lwa = lwc*lma,
         rwc = fresh_mass/fresh_mass_saturated,
         rwd = 1 - rwc,
         swc = fresh_mass_saturated/dry_mass) %>%
  unite("unique_id", c(date, sample, rep), sep = "_", remove = F) %>%
  filter(species == "blue") %>%
  mutate(date = mdy(date))

pv_new_kk_df <- pv_new_kk_raw %>%
  select(unique_id, date,water_potential, lwc, lma, lwa, rwc, rwd, swc) %>%
  mutate(week = week(date)) %>%
  filter(rwc < 1,
         rwc > 0.75) %>%
  filter(!date %in% c("2022-05-03", "2022-05-04")) #something is wrong with these dates; didn't subtract gasket or weight boat or something important (attempted to fix above but didn't work)
```

Combine: 
```{r}
pv_new_df <- bind_rows(pv_new_kk_df, pv_new_rr_df) %>% 
  filter(!(rehydrated %in% c("no")))

unique(pv_new_df$date)

unique(pv_new_df$unique_id)

```

#MPa x LWA
```{r, warning = F, echo=FALSE, fig.height=5, fig.width=7}
#scaled
pv_nice <- pv_new_df %>% 
  filter(!(date %in% c("2022-04-01", "2022-04-05")), 
         lwa < 0.05) %>% 
  ggplot(aes(y = water_potential, 
            # x = lwc_mean_centered, 
            x = lwa,
           # x = rwd,
             #color = tree_factor
            #color = as.factor(unique_id), 
           color = as.factor(date), 
           # shape = as.factor(date),
             )) +
  geom_point(alpha = 1, 
            # aes (shape = site)
             ) +
  theme(#legend.position="none",
       # legend.position= c(.7, .2),
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
     # axis.title = element_text(size = 16),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
      axis.title.x = element_text(size = 20),
     axis.title.y = element_text(size = 20), 
     legend.text = element_text(size = 13), 
     legend.title = element_text(size = 16),
     legend.margin=margin(0,0,0,0),
     # legend.box.margin=margin(-5,-8,-8,-8)
    ) +
#  geom_smooth(method = "lm", se = F) + 
 # geom_vline(xintercept = 0, linetype = "dotted") +
  labs(y= "Water Potential (MPa)", 
       x = "Leaf Water/Area (g)", 
       color = "Date", 
       shape = "Site") +
 # color_very_many +
  # scale_color_continuous(values = c("grey", "maroon", "goldenrod"))+
    # scale_color_manual(values = c("#ce4441", "#ee8577", "#eb7926", "#ffbb44", "#859b6c", "#62929a"))+
  #color_week_all +
  guides(color = guide_legend(ncol = 1))

pv_nice
```

#MPa x LWC
```{r, warning = F, echo=FALSE, fig.height=5, fig.width=7}
#scaled
pv_nice <- pv_new_df %>% 
  group_by(unique_id) %>% 
  filter(lwc < 2.1) %>% 
  filter(!(date %in% c("2022-04-01", "2022-04-05")), #these are weird? 
         lwc < 2.25) %>% 
  ggplot(aes(y = water_potential, 
            # x = lwc_mean_centered, 
            x = lwc,
           # x = rwd,
             #color = tree_factor
            #color = as.factor(unique_id), 
           color = as.factor(date), 
           # shape = as.factor(date),
             )) +
  geom_point(alpha = 1, 
            # aes (shape = site)
             ) +
  theme(#legend.position="none",
       # legend.position= c(.7, .2),
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
     # axis.title = element_text(size = 16),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
      axis.title.x = element_text(size = 20),
     axis.title.y = element_text(size = 20), 
     legend.text = element_text(size = 13), 
     legend.title = element_text(size = 16),
     legend.margin=margin(0,0,0,0),
     # legend.box.margin=margin(-5,-8,-8,-8)
    ) +
#  geom_smooth(method = "lm", se = F) + 
 # geom_vline(xintercept = 0, linetype = "dotted") +
  labs(y= "Water Potential (MPa)", 
       x = "Leaf Water Content (g)", 
       color = "Date", 
       shape = "Site") +
 # color_very_many +
  # scale_color_continuous(values = c("grey", "maroon", "goldenrod"))+
    # scale_color_manual(values = c("#ce4441", "#ee8577", "#eb7926", "#ffbb44", "#859b6c", "#62929a"))+
  #color_week_all +
  guides(color = guide_legend(ncol = 1))

pv_nice
```

#MPa x LWC - stacked
```{r, warning = F, echo=FALSE, fig.height=8, fig.width=7}
#scaled
pv_nice <- pv_new_df %>% 
  ggplot(aes(y = water_potential, 
            # x = lwc_mean_centered, 
            x = lwc,
           # x = rwd,
             #color = tree_factor
            color = as.factor(unique_id), 
            shape = as.factor(date),
             )) +
  geom_point(alpha = .5, 
            # aes (shape = site)
             ) +
  theme(legend.position="none",
       # legend.position= c(.7, .2),
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
     # axis.title = element_text(size = 16),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
      axis.title.x = element_text(size = 20),
     axis.title.y = element_text(size = 20), 
     legend.text = element_text(size = 13), 
     legend.title = element_text(size = 16),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_smooth(method = "lm", se = F) + 
 # geom_vline(xintercept = 0, linetype = "dotted") +
  labs(y= "Water Potential (MPa)", 
       x = "Leaf Water Content (g)", 
       color = "Tree", 
       shape = "Site") +
  color_very_many +
  #color_week_all +
  guides(color = guide_legend(nrow = 2)) +
  facet_wrap(~as.factor(date),nrow = 5)
pv_nice
```

#Mpa X RWC
```{r, warning = F, echo=FALSE, fig.height=4, fig.width=7}
#scaled
pv_nice_lwc <- pv_new_df %>% 
  ggplot(aes(y = water_potential, 
            # x = lwc_mean_centered, 
            x = lwc,
           # x = rwd,
             #color = tree_factor
            color = as.factor(unique_id), 
            #shape = rehydrated,
             )) +
  geom_point(alpha = .5, 
            # aes (shape = site)
             ) +
  theme(legend.position="none",
       # legend.position= c(.7, .2),
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
     # axis.title = element_text(size = 16),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
      axis.title.x = element_text(size = 20),
     axis.title.y = element_text(size = 20), 
     legend.text = element_text(size = 13), 
     legend.title = element_text(size = 16),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_smooth(method = "lm", se = F) + 
 # geom_vline(xintercept = 0, linetype = "dotted") +
  labs(y= "Water Potential (MPa)", 
       x = "Leaf Water Content (g)", 
       color = "Tree", 
       shape = "Site") +
  color_very_many +
  #color_week_all +
  guides(color = guide_legend(nrow = 2)) 
pv_nice_lwc
```


#Mpa X RWC
```{r, warning = F, echo=FALSE, fig.height=4, fig.width=7}
#scaled
pv_nice_rwc <- pv_new_df %>% 
  ggplot(aes(y = water_potential, 
            # x = lwc_mean_centered, 
            x = rwc,
           # x = rwd,
             #color = tree_factor
            color = as.factor(unique_id), 
            #shape = rehydrated,
             )) +
  geom_point(alpha = .5, 
            # aes (shape = site)
             ) +
  theme(legend.position="none",
       # legend.position= c(.7, .2),
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
     # axis.title = element_text(size = 16),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
      axis.title.x = element_text(size = 20),
     axis.title.y = element_text(size = 20), 
     legend.text = element_text(size = 13), 
     legend.title = element_text(size = 16),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_smooth(method = "lm", se = F) + 
 # geom_vline(xintercept = 0, linetype = "dotted") +
  labs(y= "Water Potential (MPa)", 
       x = "Relative Water Content (g)", 
       color = "Tree", 
       shape = "Site") +
  color_very_many +
  #color_week_all +
  guides(color = guide_legend(nrow = 2)) 
pv_nice_rwc
```

#SWC Patterns
```{r, warning = F, echo=FALSE, fig.height=4, fig.width=7}
#scaled
pv_swc <- pv_new_df %>% 
  ggplot(aes(x = date, 
            # x = lwc_mean_centered, 
            y = swc,
           # x = rwd,
             #color = tree_factor
            color = as.factor(unique_id), 
            #shape = rehydrated,
             )) +
  geom_point(alpha = .5, 
            # aes (shape = site)
             ) +
  theme(legend.position="none",
       # legend.position= c(.7, .2),
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
     # axis.title = element_text(size = 16),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
      axis.title.x = element_text(size = 20),
     axis.title.y = element_text(size = 20), 
     legend.text = element_text(size = 13), 
     legend.title = element_text(size = 16),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_smooth(method = "lm", se = F) + 
 # geom_vline(xintercept = 0, linetype = "dotted") +
  labs(y= "Saturated Water Content (g)", 
       x = "Date", 
       color = "Tree", 
       shape = "Site") +
  color_very_many +
  #color_week_all +
  guides(color = guide_legend(nrow = 2)) 
pv_swc
```


#-------
Older: 
```{r, echo=F}
pv_all_raw<- read_csv(here("data", "pv_curves", "pv_curves_long.csv"), show_col_types = FALSE) %>% 
  clean_names() %>% 
  rename(neg_mpa = x1_mpa, 
         rwd = x100_rwc) %>% 
  group_by(tree, date, rehydrated) %>% 
  fill(c(leaves_dry_wt_g, stem_dry_wt_g, 13:19), .direction = "downup") %>% 
  mutate(dry_weight = stem_dry_wt_g + leaves_dry_wt_g, 
    lw_g = case_when(
    total_nonsample_wt %in% c(NA) ~ mass_g, 
    total_nonsample_wt > 0 ~ mass_g - total_nonsample_wt), 
    lwc = lw_g/dry_weight)

pv_df <- pv_all_raw %>% 
  select(tree, date, rehydrated, mpa, rwc, rwd, lwc) %>% 
  drop_na(lwc) %>% 
  rename(water_potential = mpa) %>% 
  mutate(date = mdy(date), 
         week = week(date)) %>% 
  unite("unique_id", c("tree", "date", "rehydrated"), remove = F) %>% 
  filter(rwc > 0, 
         lwc > 0, 
         #lwc < 6,
         rwd > 0, 
         rwd < 20) 
```


#Individual trees, BOOTSTRAP:

```{r, warning = F, echo=FALSE}
#scaled
pv_nice <- pv_new_df %>% 
  ggplot(aes(y = water_potential, 
            # x = lwc_mean_centered, 
            x = lwc,
           # x = rwd,
             #color = tree_factor
            color = as.factor(unique_id), 
            #shape = rehydrated,
             )) +
  geom_point(alpha = .5, 
            # aes (shape = site)
             ) +
  theme(legend.position="none",
       # legend.position= c(.7, .2),
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
     # axis.title = element_text(size = 16),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
      axis.title.x = element_text(size = 20),
     axis.title.y = element_text(size = 20), 
     legend.text = element_text(size = 13), 
     legend.title = element_text(size = 16),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_smooth(method = "lm", se = F) + 
 # geom_vline(xintercept = 0, linetype = "dotted") +
  labs(y= "Water Potential (MPa)", 
       x = "Leaf Water Content (g)", 
       color = "Tree", 
       shape = "Site") +
  color_very_many +
  #color_week_all +
  guides(color = guide_legend(nrow = 2))
pv_nice
```

```{r, warning = F, echo=FALSE}
#scaled
pv_nice_rwc <- pv_df %>% 
  ggplot(aes(y = water_potential, 
            # x = lwc_mean_centered, 
            x = rwc,
           # x = rwd,
             #color = tree_factor
            color = as.factor(unique_id), 
            #shape = rehydrated,
             )) +
  geom_point(alpha = .5, 
            # aes (shape = site)
             ) +
  theme(legend.position="none",
       # legend.position= c(.7, .2),
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
     # axis.title = element_text(size = 16),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
      axis.title.x = element_text(size = 20),
     axis.title.y = element_text(size = 20), 
     legend.text = element_text(size = 13), 
     legend.title = element_text(size = 16),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_smooth(method = "loess", se = F) + 
 # geom_vline(xintercept = 0, linetype = "dotted") +
  labs(y= "Water Potential (MPa)", 
       x = "Relative Water Content (g)", 
       color = "Tree", 
       shape = "Site") +
  color_very_many +
  #color_week_all +
  guides(color = guide_legend(nrow = 2))
pv_nice_rwc
```


Bootstrapped slopes: 
```{r}
unique(pv_new_df$week)
unique(pv_new_df$unique_id)
```

###2022-03-30
```{r}
data <- pv_new_df %>% 
  filter(date %in% c("2022-03-30")) %>% 
  distinct() %>% 
  drop_na(water_potential, lwc) %>% 
  mutate(tree = unique_id)

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 4  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwc, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_220330 = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "2022-03-30") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_220330
```
###2022-04-07
```{r}
data <- pv_new_df %>% 
  filter(date %in% c("2022-04-07")) %>% 
  distinct() %>% 
  drop_na(water_potential, lwc) %>% 
  mutate(tree = unique_id)

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 3  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwc, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_220407 = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "2022-04-07") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_220407 
```
###2022-05-24
```{r}
data <- pv_new_df %>% 
  filter(date %in% c("2022-05-24")) %>% 
  distinct() %>% 
  drop_na(water_potential, lwc) %>% 
  mutate(tree = unique_id)

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 4  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwc, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_220504 = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "2022-05-24") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_220504
```
###2023-07-27
```{r}
data <- pv_new_df %>% 
  filter(date %in% c("2023-07-27")) %>% 
  distinct() %>% 
  drop_na(water_potential, lwc) %>% 
  mutate(tree = unique_id) %>% 
  filter(!(lma == 0))

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 20  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwc, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_230727 = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "2023-07-27") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_230727
```



```{r}
#Combining before and after: 
pv_boot_df <- bind_rows(mean_slope_220330, mean_slope_220407, 
                        mean_slope_220504, mean_slope_230727) %>% 
  select(pre_post, mean_slope, lower_bound, upper_bound) %>% 
  distinct() %>% 
  mutate(analysis = "pv curves") %>% 
  mutate(slope = mean_slope, 
         upr = as.numeric(upper_bound), 
         lwr = as.numeric(lower_bound), 
         pre_post = ymd(pre_post))
```

#Figures: 

```{r, fig.height = 2, fig.width=5}
space_slope <-  pv_boot_df %>% 
   #filter(!pre_post %in% c(9)) %>% 
  #filter(analysis == "space") %>% 
 # mutate(pre_post = as.numeric(pre_post)) %>% 
   ggplot(aes(color= as.factor(pre_post))
    ) + 
  geom_point(aes(y = slope ,x = as.factor(pre_post)), size =2) +
    geom_point(aes(y = upr, x = as.factor(pre_post)), size = 1) +
  geom_point(aes(y = lwr, x = as.factor(pre_post)), size = 1) +
  #geom_line(aes(group = pre_post, y = pre_post, x = upr)) +
  geom_segment(aes(y= lwr, 
                   yend = upr, 
                   x = as.factor(pre_post), 
                   xend = as.factor(pre_post), 
                   color = as.factor(pre_post)))+
  labs(x = "pre_post", 
       color = "pre_post", 
       y = " ") +
  theme(legend.position="none",
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
      axis.title.y = element_text(size = 15),
      axis.title.x = element_blank(),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
     legend.text = element_text(size = 13), 
    # legend.title = element_text(size = 16),
    legend.title = element_blank(),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_hline(yintercept = 0, linetype="dotted") +
 # color_pre_post_assigned+
 # color_many_2 +
  guides(color = guide_legend(nrow = 2)) 
 # scale_color_manual(values = c("darkgrey", "darkgrey")) 
 # scale_x_reverse()
space_slope

```

##All together: 
```{r}
data <- pv_new_df %>% 
  distinct() %>% 
  drop_na(water_potential, lwc) %>% 
  mutate(tree = unique_id) %>% 
  filter(!(lma == 0))

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 32  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwc, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_all = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "all") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_all
```


```{r}
write_csv(mean_slope_all, here::here("processed-data", "pv_slopes.csv"))
```


#Figures: 

```{r, fig.width=2, fig.height=2}
#Combining before and after: 
pv_boot_df <- mean_slope_all %>% 
  select(pre_post, mean_slope, lower_bound, upper_bound) %>% 
  distinct() %>% 
  mutate(analysis = "pv curves") %>% 
  mutate(slope = mean_slope, 
         upr = as.numeric(upper_bound), 
         lwr = as.numeric(lower_bound))


space_slope <-  pv_boot_df %>% 
   #filter(!pre_post %in% c(9)) %>% 
  #filter(analysis == "space") %>% 
 # mutate(pre_post = as.numeric(pre_post)) %>% 
   ggplot(aes(color= as.factor(pre_post))
    ) + 
  geom_point(aes(y = slope ,x = as.factor(pre_post)), size =2) +
    geom_point(aes(y = upr, x = as.factor(pre_post)), size = 1) +
  geom_point(aes(y = lwr, x = as.factor(pre_post)), size = 1) +
  #geom_line(aes(group = pre_post, y = pre_post, x = upr)) +
  geom_segment(aes(y= lwr, 
                   yend = upr, 
                   x = as.factor(pre_post), 
                   xend = as.factor(pre_post), 
                   color = as.factor(pre_post)))+
  labs(x = "pre_post", 
       color = "pre_post", 
       y = "Slope") +
  theme(legend.position="none",
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
     # axis.text.x = element_blank(),
      plot.title = element_text(size=13),
      axis.title.y = element_text(size = 15),
      axis.title.x = element_blank(),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
     legend.text = element_text(size = 13), 
    # legend.title = element_text(size = 16),
    legend.title = element_blank(),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_hline(yintercept = 0, linetype="dotted") +
 # color_pre_post_assigned+
 # color_many_2 +
  guides(color = guide_legend(nrow = 2)) +
 scale_color_manual(values = c("darkgrey", "darkgrey")) +
  ylim(0, 20)
 # scale_x_reverse()
space_slope

```

#--------------------------
#LWA: 

#Individual trees, BOOTSTRAP:

###2022-03-30
```{r}
data <- pv_new_df %>% 
  filter(date %in% c("2022-03-30")) %>% 
  distinct() %>% 
  drop_na(water_potential, lwa) %>% 
  mutate(tree = unique_id)

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 4  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwa, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_220330 = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "2022-03-30") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_220330
```
###2022-04-07
```{r}
data <- pv_new_df %>% 
  filter(date %in% c("2022-04-07")) %>% 
  distinct() %>% 
  drop_na(water_potential, lwa) %>% 
  mutate(tree = unique_id)

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 3  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwa, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_220407 = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "2022-04-07") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_220407 
```
###2022-05-24
```{r}
data <- pv_new_df %>% 
  filter(date %in% c("2022-05-24")) %>% 
  distinct() %>% 
  drop_na(water_potential, lwa) %>% 
  mutate(tree = unique_id)

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 4  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwa, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_220504 = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "2022-05-24") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_220504
```
###2023-07-27
```{r}
data <- pv_new_df %>% 
  filter(date %in% c("2023-07-27")) %>% 
  distinct() %>% 
  drop_na(water_potential, lwa) %>% 
  mutate(tree = unique_id) %>% 
  filter(!(lma == 0))

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 20  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwa, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_230727 = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "2023-07-27") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_230727
```



```{r}
#Combining before and after: 
pv_boot_df <- bind_rows(mean_slope_220330, mean_slope_220407, 
                        mean_slope_220504, mean_slope_230727) %>% 
  select(pre_post, mean_slope, lower_bound, upper_bound) %>% 
  distinct() %>% 
  mutate(analysis = "pv curves") %>% 
  mutate(slope = mean_slope, 
         upr = as.numeric(upper_bound), 
         lwr = as.numeric(lower_bound), 
         pre_post = ymd(pre_post))
```

#Figures: 

```{r, fig.height = 2, fig.width=5}
space_slope <-  pv_boot_df %>% 
   #filter(!pre_post %in% c(9)) %>% 
  #filter(analysis == "space") %>% 
 # mutate(pre_post = as.numeric(pre_post)) %>% 
   ggplot(aes(color= as.factor(pre_post))
    ) + 
  geom_point(aes(y = slope ,x = as.factor(pre_post)), size =2) +
    geom_point(aes(y = upr, x = as.factor(pre_post)), size = 1) +
  geom_point(aes(y = lwr, x = as.factor(pre_post)), size = 1) +
  #geom_line(aes(group = pre_post, y = pre_post, x = upr)) +
  geom_segment(aes(y= lwr, 
                   yend = upr, 
                   x = as.factor(pre_post), 
                   xend = as.factor(pre_post), 
                   color = as.factor(pre_post)))+
  labs(x = "pre_post", 
       color = "pre_post", 
       y = " ") +
  theme(legend.position="none",
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
      plot.title = element_text(size=13),
      axis.title.y = element_text(size = 15),
      axis.title.x = element_blank(),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
     legend.text = element_text(size = 13), 
    # legend.title = element_text(size = 16),
    legend.title = element_blank(),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_hline(yintercept = 0, linetype="dotted") +
 # color_pre_post_assigned+
 # color_many_2 +
  guides(color = guide_legend(nrow = 2)) 
 # scale_color_manual(values = c("darkgrey", "darkgrey")) 
 # scale_x_reverse()
space_slope

```

##All together: 
```{r}
data <- pv_new_df %>% 
  distinct() %>% 
  drop_na(water_potential, lwa) %>% 
  mutate(tree = unique_id) %>% 
  filter(!(lma == 0))

unique(data$tree)

num_unique_trees <- length(unique(data$unique_id))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 20  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwa, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

#Do the bootstrapping: 

 for (i in 1:n_iterations) {
   
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
      for (tree_id in sampled_tree_ids) {
        
        tree_data <- data %>%
          filter(tree == tree_id)
        
        # Initialize a container to store slopes for each iteration
        slopes <- vector("double", length = 1)
      
          # Calculate the slope for the bootstrapped sample
          slopes[] <- calculate_slope_for_tree(tree_data)
        
        # Store the bootstrapped slopes for this tree in the data frame
        bootstrapped_slopes_df <- bind_rows(
          bootstrapped_slopes_df,
          data.frame(
            tree = tree_id,
            slope = slopes, 
            round = i
          ) 
        ) 
      }
 }

        ci_values <- bootstrapped_slopes_df %>%
        group_by(round) %>% 
        drop_na(slope) %>%
       mutate(
          mean_slope_round = mean(slope, na.rm = T)
        ) %>% 
          ungroup() %>% 
          mutate(mean = mean(mean_slope_round, na.rm = T),
          lower_bound = quantile(mean_slope_round, 0.025, na.rm = TRUE),
          upper_bound = quantile(mean_slope_round, 0.975, na.rm = TRUE))
          
        
        # Merge the CI values back into the original dataframe
      tbootstrapped_slopes_df_before <- ci_values 
      
# Print the updated dataframe with CI values
print(tbootstrapped_slopes_df_before)

summary(tbootstrapped_slopes_df_before)

mean_slope_all = tbootstrapped_slopes_df_before %>% 
  mutate(mean_slope = mean(mean, na.rm = T),
         pre_post = "all") %>% 
  select(mean_slope, lower_bound, upper_bound, pre_post) %>% 
  distinct()
mean_slope_all
```


```{r}
write_csv(mean_slope_all, here::here("processed-data", "pv_lwa_slopes.csv"))
```


#Figures: 

```{r, fig.width=2, fig.height=2}
#Combining before and after: 
pv_boot_df <- mean_slope_all %>% 
  select(pre_post, mean_slope, lower_bound, upper_bound) %>% 
  distinct() %>% 
  mutate(analysis = "pv curves") %>% 
  mutate(slope = mean_slope, 
         upr = as.numeric(upper_bound), 
         lwr = as.numeric(lower_bound))


space_slope <-  pv_boot_df %>% 
   #filter(!pre_post %in% c(9)) %>% 
  #filter(analysis == "space") %>% 
 # mutate(pre_post = as.numeric(pre_post)) %>% 
   ggplot(aes(color= as.factor(pre_post))
    ) + 
  geom_point(aes(y = slope ,x = as.factor(pre_post)), size =2) +
    geom_point(aes(y = upr, x = as.factor(pre_post)), size = 1) +
  geom_point(aes(y = lwr, x = as.factor(pre_post)), size = 1) +
  #geom_line(aes(group = pre_post, y = pre_post, x = upr)) +
  geom_segment(aes(y= lwr, 
                   yend = upr, 
                   x = as.factor(pre_post), 
                   xend = as.factor(pre_post), 
                   color = as.factor(pre_post)))+
  labs(x = "pre_post", 
       color = "pre_post", 
       y = "Slope") +
  theme(legend.position="none",
      strip.background = element_blank(),
      strip.text.x = element_text(size = 12),
     # axis.text.x = element_blank(),
      plot.title = element_text(size=13),
      axis.title.y = element_text(size = 15),
      axis.title.x = element_blank(),
     axis.text = element_text(size = 12),
     legend.key=element_blank(), 
     legend.text = element_text(size = 13), 
    # legend.title = element_text(size = 16),
    legend.title = element_blank(),
     legend.margin=margin(0,0,0,0),
      legend.box.margin=margin(-5,-8,-8,-8)
    ) +
  geom_hline(yintercept = 0, linetype="dotted") +
 # color_pre_post_assigned+
 # color_many_2 +
  guides(color = guide_legend(nrow = 2)) +
 scale_color_manual(values = c("darkgrey", "darkgrey")) 
 # scale_x_reverse()
space_slope

```

