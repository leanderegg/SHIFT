---
title: "Establishing relationships between LWC and MPa, Part 2"
author: "Indra Boving"
date: "11/9022"
output:
  html_document: default
  word_document: default
---

#Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
library(tidyverse)
library(boot)
source(here::here("scripts", "scripts_functions", "figure_info.R"))
```

```{r}
data_og <- read_csv(here::here("processed-data", "wp_wc_df.csv")) %>% 
  filter(species == "blue oak") %>% 
  mutate(time_period = case_when(
    week <= 17 ~ "before leafout", 
    week > 17 ~ "after leafout", 
    TRUE ~ as.character("none")
  )) %>% 
  filter(!(week == 29 & lwc_mean > 1), 
         !(week == 29 & lwc_mean < .451), 
         !(week == 15 & lwc_mean < .7), 
         !(week == 33 & tree == 2347), 
         !(week == 18)) %>% #seems off
  mutate(water_potential = -1*mpa_mean, 
         lwc = lwc_mean) %>% 
  select(tree, week, water_potential, lwc, time_period, time, date_wp) %>% 
  distinct()

dates <- data_og %>% 
  select(week, date_wp) %>% 
  distinct()
```


#TIME - ind. trees:

Here, the slopes for individual trees are kept separate

```{r}
data_all <- data_og %>% 
  filter(time == "md") 

# Filter for trees measured "before leafout"
before_leafout_data <- data_all %>%
  filter(time_period == "before leafout")

# Filter for trees measured "after leafout"
after_leafout_data <- data_all %>%
  filter(time_period == "after leafout")

# Find the common set of trees that appear in both datasets
common_trees <- intersect(before_leafout_data$tree, after_leafout_data$tree)

# Filter the original dataset to include only the common trees
common_trees_data <- data_all %>%
  filter(tree %in% common_trees)

# Assuming you have the 'common_trees_data' dataframe

# Get the unique tree IDs in 'common_trees_data'
unique_tree_ids <- unique(common_trees_data$tree)

# Count the number of unique tree IDs
num_unique_tree_ids <- length(unique_tree_ids)

# Print the number of unique tree IDs
cat("Number of unique tree IDs in common_trees_data:", num_unique_tree_ids, "\n")

# Filter the original dataset to include only the common tree IDs
filtered_data <- data_all[data_all$tree %in% common_trees, ] 
```

###Before leafout: 
```{r}
data <- filtered_data  %>% 
  filter(time_period == "before leafout") %>% 
  distinct() %>% 
  drop_na(water_potential, lwc) %>% 
  filter(!tree %in% c(2012, 2011))

num_unique_trees <- length(unique(data$tree))
cat("Number of unique trees in the dataset:", num_unique_trees, "\n")
```

```{r}
data %>% 
  #filter(tree == 1478) %>% 
  ggplot(aes(y = water_potential, 
             x = lwc, 
             color= as.factor(tree))) +
  geom_point() +
  geom_smooth(method = "lm", se = F)

```

#New:
```{r}
# Load necessary libraries
library(tidyverse)
library(boot)

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 40  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwc, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

 for (i in 1:n_iterations) {
# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
for (tree_id in sampled_tree_ids) {
  tree_data <- data %>%
    filter(tree == tree_id)
  
  # Initialize a container to store slopes for each iteration
  slopes <- vector("double", length = 1)

    # Calculate the slope for the bootstrapped sample
    slopes[i] <- calculate_slope_for_tree(tree_data)
  }
  
  # Store the bootstrapped slopes for this tree in the data frame
  bootstrapped_slopes_df <- bind_rows(
    bootstrapped_slopes_df,
    data.frame(
      tree = tree_id,
      bootstrapped_slope = slopes
    )
  ) 
}

bootstrapped_slopes_df <- bootstrapped_slopes_df %>% 
  drop_na(bootstrapped_slope)
# Print the resulting long dataframe with bootstrapped slopes
print(bootstrapped_slopes_df)

#drop NAs: 

# Calculate the 95% confidence interval across the boostrapped slopes:
ci_values <- bootstrapped_slopes_df %>%
  drop_na(bootstrapped_slope) %>%
  summarise(
    lower_bound = quantile(bootstrapped_slope, 0.025, na.rm = TRUE),
    upper_bound = quantile(bootstrapped_slope, 0.975, na.rm = TRUE)
  )

# Merge the CI values back into the original dataframe
bootstrapped_slopes_df2 <- merge(bootstrapped_slopes_df, ci_values)

# Print the updated dataframe with CI values
print(bootstrapped_slopes_df2)

summary(bootstrapped_slopes_df2)
```


#Old: 
```{r, eval = F}
# Load necessary libraries
library(tidyverse)
library(boot)

# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 40  # Adjust as needed
```

Pull mean slope from those 40 trees, store that. 

do that 1000x

take mean from that and CI. 
```{r, eval = F}
# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwc, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
for (tree_id in sampled_tree_ids) {
  tree_data <- data %>%
    filter(tree == tree_id)
  
  # Initialize a container to store slopes for each iteration
  slopes <- vector("double", length = n_iterations)
  
  # Perform bootstrapping for each iteration
  for (i in 1:n_iterations) {
    # Randomly sample rows without replacement (so lines arent just points)
    
    boot_indices <- sample(nrow(tree_data), replace = F)
    boot_sample <- tree_data[boot_indices, ]
    
    # Calculate the slope for the bootstrapped sample
    slopes[i] <- calculate_slope_for_tree(boot_sample)
    
     # Check if there are both "pd" and "md" rows for the tree
    if (nrow(tree_data) >= 2) {
      # Calculate the slope for the tree
      slope[i] <- calculate_slope_for_tree(tree_data)
    }
  }
  
  # Store the bootstrapped slopes for this tree in the data frame
  bootstrapped_slopes_df <- bind_rows(
    bootstrapped_slopes_df,
    data.frame(
      tree = tree_id,
      bootstrapped_slope = slopes
    )
  )
}

# Print the resulting long dataframe with bootstrapped slopes
print(bootstrapped_slopes_df)

# Calculate the 95% confidence interval across the boostrapped slopes:
ci_values <- bootstrapped_slopes_df %>%
  #group_by(tree) %>%
  summarise(
    lower_bound = quantile(bootstrapped_slope, 0.025, na.rm = TRUE),
    upper_bound = quantile(bootstrapped_slope, 0.975, na.rm = TRUE)
  )

# Merge the CI values back into the original dataframe
bootstrapped_slopes_df2 <- merge(bootstrapped_slopes_df, ci_values)

# Print the updated dataframe with CI values
print(bootstrapped_slopes_df2)

summary(bootstrapped_slopes_df2)
```


```{r}
# Remove missing values and NaNs from the 'bootstrapped_slope' column
cleaned_slopes <- na.omit(bootstrapped_slopes_df2$bootstrapped_slope)

# Calculate the 95% confidence interval for the cleaned slopes
left <- quantile(cleaned_slopes, 0.025)
right <- quantile(cleaned_slopes, 0.975)

# Print the confidence interval
cat("95% Confidence Interval for Bootstrapped Slopes:\n")
cat("Lower Bound:", left, "\n")
cat("Upper Bound:", right, "\n")

# Load necessary libraries
library(tidyverse)

# Create a histogram of bootstrapped slopes
ggplot(bootstrapped_slopes_df2, aes(x = bootstrapped_slope)) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black") +
  geom_vline(xintercept = left, color = "red", linetype = "dashed", size = 1) +
  geom_vline(xintercept = right, color = "red", linetype = "dashed", size = 1) +
  labs(
    title = "Histogram of Bootstrapped Slopes, Post_leafout",
    x = "Slope",
    y = "Frequency"
  ) +
  theme_minimal()
```


```{r}
mean_slope_before = bootstrapped_slopes_df2 %>% 
  mutate(mean_slope = mean(bootstrapped_slope, na.rm = T),
         pre_post = "before leafout")
mean_slope_before
```

###After leafout: 
```{r}
# Load necessary libraries
library(tidyverse)
library(boot)

data <- common_trees_data %>% 
  filter(time_period == "after leafout") %>% 
  select(tree, week, water_potential, lwc) %>% 
  distinct() %>% 
  drop_na(water_potential, lwc)
```

```{r}
# Assuming your dataset is called 'data'
# Make sure 'data' is properly loaded before proceeding

# Define the number of bootstrap iterations
n_iterations <- 1000

# Number of random trees to sample
n_sample_trees <- 40  # Adjust as needed

# Create an empty data frame to store bootstrapped slopes
bootstrapped_slopes_df <- data.frame()

# Function to calculate the slope for a specific tree within each iteration
calculate_slope_for_tree <- function(tree_data) {
  model <- lm(water_potential ~ lwc, data = tree_data)
  return(coef(model)[2])  # Extract the slope coefficient
}

# Randomly sample 'n_sample_trees' trees from your dataset
sampled_tree_ids <- sample(unique(data$tree), size = n_sample_trees, replace = TRUE)

# Iterate through each sampled tree and perform bootstrapping separately
for (tree_id in sampled_tree_ids) {
  tree_data <- data %>%
    filter(tree == tree_id)
  
  # Initialize a container to store slopes for each iteration
  slopes <- vector("double", length = n_iterations)
  
  # Perform bootstrapping for each iteration
  for (i in 1:n_iterations) {
    # Randomly sample rows with replacement
    boot_indices <- sample(nrow(tree_data), replace = F)
    boot_sample <- tree_data[boot_indices, ]
    
    # Calculate the slope for the bootstrapped sample
    slopes[i] <- calculate_slope_for_tree(boot_sample)
  }
  
  # Store the bootstrapped slopes for this tree in the data frame
  bootstrapped_slopes_df <- bind_rows(
    bootstrapped_slopes_df,
    data.frame(
      tree = tree_id,
      bootstrapped_slope = slopes
    )
  )
}

# Print the resulting long dataframe with bootstrapped slopes
print(bootstrapped_slopes_df)

# Calculate the 95% confidence interval across the boostrapped slopes:
ci_values <- bootstrapped_slopes_df %>%
  #group_by(tree) %>%
  summarise(
    lower_bound = quantile(bootstrapped_slope, 0.025, na.rm = TRUE),
    upper_bound = quantile(bootstrapped_slope, 0.975, na.rm = TRUE)
  )

# Merge the CI values back into the original dataframe
bootstrapped_slopes_df2 <- merge(bootstrapped_slopes_df, ci_values)

# Print the updated dataframe with CI values
print(bootstrapped_slopes_df2)
```


```{r}
# Remove missing values and NaNs from the 'bootstrapped_slope' column
cleaned_slopes <- na.omit(bootstrapped_slopes_df2$bootstrapped_slope)

# Calculate the 95% confidence interval for the cleaned slopes
left <- quantile(cleaned_slopes, 0.025)
right <- quantile(cleaned_slopes, 0.975)

# Print the confidence interval
cat("95% Confidence Interval for Bootstrapped Slopes:\n")
cat("Lower Bound:", left, "\n")
cat("Upper Bound:", right, "\n")

# Load necessary libraries
library(tidyverse)

# Create a histogram of bootstrapped slopes
ggplot(bootstrapped_slopes_df, aes(x = bootstrapped_slope)) +
  geom_histogram(binwidth = 0.1, fill = "blue", color = "black") +
  geom_vline(xintercept = left, color = "red", linetype = "dashed", size = 1) +
  geom_vline(xintercept = right, color = "red", linetype = "dashed", size = 1) +
  labs(
    title = "Histogram of Bootstrapped Slopes, Post_leafout",
    x = "Slope",
    y = "Frequency"
  ) +
  theme_minimal()

```

```{r}
mean_slope_after = bootstrapped_slopes_df2 %>% 
  mutate(mean_slope = mean(bootstrapped_slope, na.rm = T),
         pre_post = "after leafout")
mean_slope_after
```


```{r}
#Combing before and after: 
time_boot_df <- bind_rows(mean_slope_before, mean_slope_after) %>% 
 # filter(bootstrapped_slope < 100) %>% #these really high ones are just wrong!! Can I do this, though?
  group_by(tree, pre_post) %>% 
  mutate(tree_mean = mean(bootstrapped_slope, na.rm = T)) %>% 
  ungroup() %>% 
  select(tree, pre_post, tree_mean, lower_bound, upper_bound) %>% 
  distinct() %>% 
  mutate(analysis = "time, ind. tree")
```

```{r}
time_boot_df %>% 
  group_by(pre_post) %>% 
  mutate(tree_mean = mean(tree_mean, na.rm = T)) %>% 
  ggplot() +
  geom_point(aes(y = tree_mean, 
             x = pre_post)) +
  geom_point(aes(y = upper_bound, 
                 x= pre_post), color = "blue")  +
  geom_point(aes(y = lower_bound, 
                 x= pre_post), color = "pink")  +
  theme_minimal()
```
#TIME - combine trees 

```{r}
data <- filtered_data  %>% 
  distinct() %>% 
  drop_na(water_potential, lwc)

num_unique_trees <- length(unique(data$tree))

# Assuming your original dataframe is called 'data'

# Define the number of bootstrap iterations
n_iterations <- 1000

# Create an empty dataframe to store results
final_df_time <- data.frame(time_period = character(), mean_slope = numeric(), lower_bound = numeric(), upper_bound = numeric())

# Get unique time periods in your dataset
unique_time_periods <- unique(data$time_period)

# Custom function for bootstrapping within each time period
bootstrap_within_time <- function(data, tp) {  # Rename the loop variable to 'tp'
  time_data <- data %>%
    filter(time_period == tp)  # Use 'tp' instead of 'time_period'
  
  # Check if there are any valid data points for bootstrapping
  if (nrow(time_data) == 0) {
    # Return NA values for this time period
    return(data.frame(time_period = tp, mean_slope = NA, lower_bound = NA, upper_bound = NA))
  }
  
  # Initialize a container to store bootstrapped slopes
  slopes <- vector("double", length = n_iterations)
  
  # Perform bootstrapping to estimate slopes
  for (i in 1:n_iterations) {
    # Randomly sample rows with replacement
    boot_indices <- sample(nrow(time_data), replace = TRUE)
    boot_sample <- time_data[boot_indices, ]
    
    # Check if there are any valid data points in the bootstrapped sample
    if (nrow(boot_sample) == 0) {
      # Skip this iteration and assign NA to the slope
      slopes[i] <- NA
    } else {
      # Calculate the slope for the bootstrapped sample
      model <- lm(water_potential ~ lwc, data = boot_sample)
      slopes[i] <- coef(model)[2]
    }
  }
  
  # Remove NA values from slopes
  slopes <- slopes[!is.na(slopes)]
  
  # Check if there are any valid slopes
  if (length(slopes) == 0) {
    # Return NA values for this time period
    return(data.frame(time_period = tp, mean_slope = NA, lower_bound = NA, upper_bound = NA))
  }
  
  # Calculate the mean slope and 95% CI
  mean_slope <- mean(slopes)
  lower_bound <- quantile(slopes, 0.025)
  upper_bound <- quantile(slopes, 0.975)
  
  return(data.frame(time_period = tp, mean_slope = mean_slope, lower_bound = lower_bound, upper_bound = upper_bound))
}

# Iterate through each time period
for (tp in unique_time_periods) {  # Rename the loop variable to 'tp'
  # Step 1: Filter data for the current time period
  time_data <- data %>%
    filter(time_period == tp)  # Use 'tp' instead of 'time_period'
  
  # Step 2: Perform bootstrapping and calculate slopes for the current time period
  results <- bootstrap_within_time(time_data, tp)  # Use 'tp' instead of 'time_period'
  
  # Step 3: Store the results in the final dataframe
  final_df_time <- bind_rows(final_df_time, results)
}

# Print the final dataframe
print(final_df_time)

# Visualize histograms for each time period side by side using ggplot
final_df_time %>% 
  ggplot() +
  geom_point(aes(y = mean_slope, 
             x = time_period), size = 4) +
  geom_point(aes(y = upper_bound, 
                 x= time_period))  +
  geom_point(aes(y = lower_bound, 
                 x= time_period)) +
  labs(x = "Time Period", y = "Slope", title = "Bootstrap Distribution of Slopes by Time Period") +
  scale_fill_manual(values = c("before leafout" = "blue", "after leafout" = "red")) +
  theme_minimal()


```

#SPACE: 

```{r}
data <- data_og %>% 
  filter(time == "md") %>% 
  select(tree, week, water_potential, lwc) %>% 
  distinct() %>% 
  drop_na(lwc, water_potential)

head(data)

data %>% 
ggplot(aes(y = water_potential, 
           x = lwc, 
           color = as.factor(week))) +
  geom_point(alpha = .5) +
  geom_smooth(method = "lm", se = F)
```
Cant actually filter by trees that were in all weeks, because none were actually sampled in all weeks. Maybe just ignore? 

```{r}
# Define the number of bootstrap iterations
n_iterations <- 1000

# Create an empty dataframe to store results
final_df_space <- data.frame(week = integer(), mean_slope = numeric(), lower_bound = numeric(), upper_bound = numeric())

# Get unique weeks in your dataset
unique_weeks <- unique(data$week)

# Iterate through each week
for (x in unique_weeks) {
  # Step 1: Filter data for the current week
  week_data <- data %>%
    filter(week == x)
  
  # Step 2: Initialize a container to store bootstrapped slopes
  slopes <- vector("double", length = n_iterations)
  
  # Step 3: Perform bootstrapping to estimate slopes
  for (i in 1:n_iterations) {
    # Randomly sample rows with replacement
    boot_indices <- sample(nrow(week_data), replace = TRUE)
    boot_sample <- week_data[boot_indices, ]
    
    # Calculate the slope for the bootstrapped sample
    model <- lm(water_potential ~ lwc, data = boot_sample)
    slopes[i] <- coef(model)[2]
  }
  
  # Step 4: Calculate the mean slope and 95% CI
  mean_slope <- mean(slopes)
  lower_bound <- quantile(slopes, 0.025)
  upper_bound <- quantile(slopes, 0.975)
  
  # Step 5: Store the results in the final dataframe
  final_df_space <- bind_rows(final_df_space, data.frame(week = x, mean_slope = mean_slope, lower_bound = lower_bound, upper_bound = upper_bound))
}

# Print the final dataframe
print(final_df_space)
```


```{r}
final_df_space %>% 
  ggplot(aes(x = week)) +
   geom_segment(aes(y= lower_bound, 
                   yend = upper_bound, 
                   x = week, 
                   xend = week, 
                   color = as.factor(week)))+
  geom_point(aes(y = mean_slope), color = "cyan") +
  geom_point(aes(y = lower_bound), color = "pink") +
  geom_point(aes(y = upper_bound), color = "gold") +
  geom_hline(yintercept =0) +
  labs(y = "Slope",
       x = "Week")
  
```
#HYDRATION: 

```{r}
data <- data_og %>% 
  select(tree, week, water_potential, lwc, time) %>%
  drop_na(lwc, water_potential) %>% 
  group_by(tree, week) %>%
  filter(all(c("pd", "md") %in% time)) %>%
  ungroup() %>% 
  distinct() 


head(data)

```

```{r}
df_all_groups <- data %>% 
  mutate(tree_week = paste(tree, week, sep = "_")
  ) %>% 
  mutate(water_potential = water_potential)
  

df_grey <- df_all_groups

df_1 <- df_all_groups %>% 
  filter(week %in% c('10'))

df_2 <- df_all_groups %>% 
  filter(week %in% c('19'))

df_3 <- df_all_groups %>% 
  filter(week %in% c('21'))

df_4 <- df_all_groups %>% 
  filter(week %in% c('37'))

nice_hydration_layered <- ggplot() +
    geom_point(aes(y = water_potential, x = lwc, shape = time), data = df_grey, color = "grey") +
    geom_line(aes(y = water_potential, x = lwc, group = tree_week), color = "grey", data = df_grey) +
    geom_point(aes(y = water_potential, x = lwc, shape = time, color = "df_1"), 
               data = df_1 ) +
    geom_line(aes(y = water_potential, x = lwc, group = tree_week, color = "df_1"), 
              data = df_1) +
    geom_point(aes(y = water_potential, x = lwc, shape = time, color = "df_2"), 
               data = df_2) +
    geom_line(aes(y = water_potential, x = lwc, group = tree_week, color = "df_2"), 
              data = df_2) +
    # geom_point(aes(y = water_potential, x = lwc, shape = time, color = "df_3"), 
    #            data = df_3) +
    # geom_line(aes(y = water_potential, x = lwc, group = tree_week, color = "df_3"), 
    #           data = df_3) +
    # geom_point(aes(y = water_potential, x = lwc, shape = time, color = "df_4"), 
    #            data = df_4) +
    # geom_line(aes(y = water_potential, x = lwc, group = tree_week, color = "df_4"), 
    #           data = df_4
    #           ) +
    scale_colour_manual(name = 'Week', 
         values =c("df_1" ="#122451", 
                   "df_2"="#62929a",
                  # "df_3"="#EC7E28",
                   "df_4"="#c969a8"
                   ), 
         labels = c('10',
                    '17',
                  #  '21',
                    '33')) +
    labs(y = "Water Potential (MPa)", 
       x = "Leaf Water Content (g)", 
       color= "Week", 
       shape = "Time"
       #caption = "triangles = predawn, circles = midday"
       ) +
  theme(
    #legend.position = c(.9, .35),
   # legend.position = "none",
     legend.position = "right",
  #strip.background = element_blank(),
  #strip.text.y = element_blank(), 
  #strip.text.x = element_text(size = 16), 
  axis.text.y = element_text(size = 12), 
  axis.text.x = element_text(size = 12), 
  #axis.ticks.y = element_blank(), 
  axis.title.y = element_text(size = 20), 
  axis.title.x = element_text(size = 20), 
 # axis.title.x = element_blank(),
  legend.title = element_text(size = 14), 
  legend.text = element_text(size = 14), 
# legend.position = "none"
  ) +
   xlim(.5,2) +
  scale_x_reverse()
nice_hydration_layered

data_og %>% 
  ggplot(aes(y = lwc, x = week)) +
  geom_point()+
  facet_wrap(~time)
```
```{r}
data %>% 
  filter(week == '14') %>% 
  mutate(tree_week = paste(tree, week, sep = "_")
  ) %>% 
  mutate(water_potential = water_potential) %>% 
  ggplot(aes(y = water_potential, x = lwc, color =    as.factor(tree))) +
    geom_point(aes(shape = time)) +
  geom_smooth(method = "lm")

```

####Trees individually: 

Pull 40 trees, get mean slope for those 40, do 1000x. 

```{r}
# Load necessary libraries
library(dplyr)
library(boot)

# Assuming your original dataframe is called 'data'

# Define the number of bootstrap iterations
n_iterations <- 1000

# Create an empty dataframe to store results
results_df <- data.frame(week = numeric(), tree = numeric(), slope = numeric())

# Custom function to calculate the slope for a tree within a week
calculate_slope_for_tree <- function(y) {
  model <- lm(water_potential ~ lwc, data = y)
  return(coef(model)[2])
}

# Iterate through each unique week
unique_weeks <- unique(data$week)

for (x in unique_weeks) {
  # Filter data for the current week
  week_data <- data %>%
    filter(week == x)
  
  # Perform bootstrapping for each iteration
  for (i in 1:n_iterations) {
    # Randomly sample a tree with replacement
    sampled_tree <- sample(unique(week_data$tree), size = 1, replace = FALSE)
  
    # Filter data for the sampled tree
    tree_data <- week_data %>%
      filter(tree == sampled_tree)
    
    # Check if there are both "pd" and "md" rows for the tree
    if (nrow(tree_data) >= 2) {
      # Calculate the slope for the tree
      slope <- calculate_slope_for_tree(tree_data)
      
      # Store the results in the dataframe
      results_df <- bind_rows(results_df, data.frame(week = x, tree = sampled_tree, slope = slope)) 
    }
  }
}

# Print the results dataframe
print(results_df)

# Calculate the mean and 95% CI for each week
summary_df_hyd <- results_df %>%
  filter(slope < 15, 
         slope > -15) %>% 
  group_by(week) %>%
  summarize(
    mean_slope = mean(slope),
    lower_bound = quantile(slope, 0.025),
    upper_bound = quantile(slope, 0.975)
  )

# Print the summary dataframe
print(summary_df_hyd)
```

```{r}
summary_df_hyd %>% 
  ggplot(aes(x = week)) +
   geom_segment(aes(y= lower_bound, 
                   yend = upper_bound, 
                   x = week, 
                   xend = week, 
                   color = as.factor(week)))+
  geom_point(aes(y = mean_slope), color = "cyan") +
  geom_point(aes(y = lower_bound), color = "pink") +
  geom_point(aes(y = upper_bound), color = "gold") +
  labs(y = "Slope",
       x = "Week")
```
####All trees together: 

No random effect of tree

```{r}
# Load necessary libraries
library(tidyverse)

# Assuming your original dataframe is called 'data'

# Define the number of bootstrap iterations
n_iterations <- 1000

# Create an empty dataframe to store results
final_df <- data.frame(week = integer(), mean_slope = numeric(), lower_bound = numeric(), upper_bound = numeric())

# Get unique weeks in your dataset
unique_weeks <- unique(data$week)

# Iterate through each week
for (x in unique_weeks) {
  # Step 1: Filter data for the current week
  week_data <- data %>%
    filter(week == x)
  
  # Step 2: Initialize a container to store bootstrapped slopes
  slopes <- vector("double", length = n_iterations)
  
  # Step 3: Perform bootstrapping to estimate slopes
  for (i in 1:n_iterations) {
    # Randomly sample unique trees with replacement
    sampled_trees <- sample(unique(week_data$tree), replace = TRUE)
    
    # Filter data to include both "pd" and "md" rows for the sampled trees
    boot_sample <- week_data %>%
      filter(tree %in% sampled_trees, time %in% c("pd", "md"))
    
    # Calculate the slope for the bootstrapped sample
    model <- lm(water_potential ~ lwc, data = boot_sample)
    slopes[i] <- coef(model)[2]
  }
  
  # Step 4: Calculate the mean slope and 95% CI
  mean_slope <- mean(slopes, na.rm = TRUE)
  lower_bound <- quantile(slopes, 0.025, na.rm = TRUE)
  upper_bound <- quantile(slopes, 0.975, na.rm = TRUE)
  
  # Step 5: Store the results in the final dataframe
  final_df <- bind_rows(final_df, data.frame(week = x, mean_slope = mean_slope, lower_bound = lower_bound, upper_bound = upper_bound))
}

# Print the final dataframe
print(final_df)

```

```{r}
final_df %>% 
#results_df %>% 
  ggplot(aes(x = week)) +
   geom_segment(aes(y= lower_bound, 
                   yend = upper_bound, 
                   x = week, 
                   xend = week, 
                   color = as.factor(week)))+
  geom_point(aes(y = mean_slope), color = "cyan") +
  geom_point(aes(y = lower_bound), color = "pink") +
  geom_point(aes(y = upper_bound), color = "gold") +
  labs(y = "Slope",
       x = "Week")
  
```
#COMBINE DF:

should be week, mean_slope, lower_bound, upper_bound

```{r}
final_df_hyd <- final_df %>% 
  mutate(analysis = "hydration", 
         time_period = "NA")

summary_df_hyd <- summary_df_hyd %>% 
  mutate(analysis = "hydration, ind. trees", 
         time_period = "NA")

final_df_space <- final_df_space %>% 
  mutate(analysis = "space", 
         time_period = "NA")

final_df_time <- final_df_time %>% 
  mutate(analysis = "time", 
         week = 0)

time_boot_df <- time_boot_df %>% 
  group_by(pre_post) %>% 
  mutate(week = 0, 
         mean_slope = mean(tree_mean, na.rm = T), 
         time_period = pre_post) %>% 
  ungroup()

final_df_all <- bind_rows(final_df_hyd, summary_df_hyd, final_df_space, final_df_time, time_boot_df) %>% 
  mutate(slope = mean_slope, 
         lwr = lower_bound, 
         upr = upper_bound) %>% write_csv(here::here("processed-data", "bootstrapped_df_lwc.csv"))
```

